use std::str::FromStr;

use ast::*;
use ast::eq::*;
use ast::neq::*;
use ast::add::*;
use ast::number::*;
use ast::boolean::*;

__
    = [ \t]*

expr -> Box<Node>
    = t:equality { t }
    / t:term     { t }
    / t:factor   { t }
    / t:atom     { t }


number -> NodeNumber
    = n:([0-9]+ { i64::from_str(match_str).unwrap() }) __ { NodeNumber::new(n) }

boolean -> NodeBoolean
    = "true"  __ { NodeBoolean::new(true)  }
    / "false" __ { NodeBoolean::new(false) }

atom -> Box<Node>
    = t:boolean    { Box::new(t) }
    / t:number     { Box::new(t) }
    / "(" __ t:expr __ ")" { t }


// Equality
equals -> Box<Node>
    = l:(term / atom) __ "==" __ r:expr { Box::new(NodeEq::new(l, r)) }

not_equals -> Box<Node>
    = l:(term / atom) __ "!=" __ r:expr { Box::new(NodeNeq::new(l, r)) }

equality -> Box<Node>
    = t:equals     { t }
    / t:not_equals { t }


// Terms
addition -> Box<Node>
    = l:(factor / atom) __ "+" __ r:expr { Box::new(NodeAdd::new(l, r)) }

subtraction -> Box<Node>
    = l:(factor / atom) __ "-" __ r:expr { Box::new(NodeAdd::new(l, r)) }

term -> Box<Node>
    = t:addition    { t }
    / t:subtraction { t }


// Factors
multiply -> Box<Node>
    = l:atom __ "*" __ r:(factor / atom) { Box::new(NodeAdd::new(l, r)) }

divide -> Box<Node>
    = l:atom __ "/" __ r:(factor / atom) { Box::new(NodeAdd::new(l, r)) }

factor -> Box<Node>
    = t:multiply { t }
    / t:divide   { t }


#[pub]
machine -> Machine
    = __ e:expr __ { Machine::new(e) }
